
    class TinyError
    {
    public:
        TinyError() :
            error_flag(false) {}

        bool has_errors() const;
        virtual void report_errors(std::ostream &out = std::cout);
    
    protected:
        void add_dependency(TinyError *dep) { deps.push_back(dep); }
        bool error_flag;

    private:
        vector<TinyError*> deps;

    };

    class Lexer : public TinyError
    {
    public:
        Lexer(std::istream &stream);
        Lexer(string file_path);
        ~Lexer();

        char read_char(int index);
        char *read_string(int index, int len);

        void error(string msg);
        void error(string msg, Token token);
        void report_errors(std::ostream &out = std::cout);

        Token next();
        Token match(Token::TokenType type, string name);
        const Token &get_look() const { return look; }
        inline bool is_eof() const { return eof_flag; }

    private:
        enum class MatchStatus
        {
            MATCH,
            BLANK,
            ERROR
        };
        MatchStatus next_match(Token &token);
        void init();

        enum class ErrorType
        {
            ParseError,
            IOError,
            Warning,
        };

        struct Error
        {
            ErrorType type;
            string message;
            int index;
        };

        std::istream &in;
        std::ifstream file_in;
        char *cache;
        int index;

        vector<Error> errors;
        bool eof_flag;
        Token look;

    };
