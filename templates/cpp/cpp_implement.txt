
    Lexer::Lexer(std::istream &stream) :
        in(stream), eof_flag(false), index(0)
	{
        init();
	}

    Lexer::Lexer(string file_path) :
        in(file_in), eof_flag(false), 
        index(0), line_index(0),
        line(1), column(1)
    {
        file_in = std::ifstream(file_path, std::ifstream::binary);
        if (!file_in.good())
        {
            // If the file could not be opened, trigger an error
            error("Could not open input file '" + file_path + "'");
            eof_flag = true;
            cache = nullptr;
            return;
        }

        init();
    }

    void Lexer::init()
    {
        cache = new char[128];
        next();
    }

    char Lexer::read_char(int index)
    {
        in.clear();
        in.seekg(index);
        return in.get();
    }

    char *Lexer::read_buffer(int index, int len)
    {
        in.clear();
        in.seekg(index);
        in.get(cache, len + 1);
        return cache;
    }

    string Lexer::read_string(int index, int len)
    {
        char *buffer = read_buffer(index, len);
        return string(buffer, len);
    }

    Lexer::MatchStatus Lexer::next_match(Token &token)
    {
        unsigned int state, next_state;
        char next_char, type;

        // Assign token info
        look.data_index = index;
        look.line_index = line_index;
        look.line_no = line;
        look.column_no = column;
        look.len = 0;

        state = 0;
        for (;;)
        {
            next_char = read_char(index);
            if (next_char == -1)
                break;

            next_state = table[state * CHAR_COUNT + next_char];
#ifdef TINYLEX_DEBUG
            printf("%u -%c-> %u\n", state, next_char, next_state);
#endif

            index += 1;
            column += 1;
            if (next_char == '\n')
            {
                line_index = index;
                line += 1;
                column = 1;
            }

            if (next_state == NONE)
            {
                // If the end state is not valid, 
                // there's no match
                type = end_states[state];
#ifdef TINYLEX_DEBUG
                printf("Ending: %i -> %i\n", state, type);
#endif
                if (type == -1)
                    break;

                // Otherwise there is one, so return so
                look.type_name = type_names[type];
                look.type = (Token::TokenType)type;
                index -= 1;
                column -= 1;
                return Lexer::MatchStatus::MATCH;
            }

            state = next_state;
            look.len += 1;
        }

        // If there's nothing left, mark so
        if (read_char(index) == EOF)
            eof_flag = 1;

        // If no types match
        return Lexer::MatchStatus::BLANK;
    }

    Token Lexer::next()
    {
        Token last = look;

        // Find the next valid token
        Lexer::MatchStatus status;
        do
        {
            status = next_match(look);
        } while (status != Lexer::MatchStatus::MATCH && !eof_flag);

        return last;
    }

    Token Lexer::match(Token::TokenType type, string name)
    {
        // Check token type info
        if (look.type != type)
        {
            error("Expected '" + name + "', got '" + 
                string("lolz") + "' instead", look);
        }

        // Get the next token
        return next();
    }

    void Lexer::error(string msg)
    {
        Error error;
        error.type = ErrorType::IOError;
        error.message = msg;
        errors.push_back(error);

        error_flag = true;
    }

    void Lexer::error(string msg, Token token)
    {
        Error error;
        error.type = ErrorType::ParseError;
        error.message = msg;
        error.index = token.data_index;
        errors.push_back(error);

        error_flag = true;
    }

    void Lexer::report_errors(std::ostream &out)
    {
        for (Error &error : errors)
        {
            out << "Error: " << error.message << std::endl;
        }
    }

    Lexer::~Lexer()
    {
        if (cache != nullptr)
            delete[] cache;
        file_in.close();
    }
